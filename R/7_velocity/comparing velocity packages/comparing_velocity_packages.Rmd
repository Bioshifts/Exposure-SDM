---
title: "Comparing velocity packages"
author: "Brunno Oliveira"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  pdf_document:
    toc: yes
  html_document:
    toc: yes
    toc_float: yes
    number_sections: yes
    code_folding: show
---

# setup
```{r message=FALSE, warning=FALSE}

# devtools::install_github("cbrown5/vocc")
# devtools::install_github("oliveirab/VoCC", build_vignettes = FALSE)

list.of.packages <- c("climetrics","vocc","VoCC1","terra","ggplot2","GGally","data.table","geodata","tidyterra")
# new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
# if(length(new.packages)) install.packages(new.packages)
sapply(list.of.packages, require, character.only = TRUE)

# Source velocity functions adapted from the package climetrics after applying some corrections described below 
# source("/storage/simple/projects/t_cesab/brunno/Exposure-SDM/R/velocity_functions.R")
source(here::here("R/velocity_functions.R"))
# Source function generated by Gael to create the spatial gradient at the latitudinal direction.
source(here::here("R/gael_velocity.R"))
# Source settings (here used only to the Eckert equal area projection)
source(here::here("R/settings.R"))

```

In order to generate comparable results across multiple R packages, we sourced climate data from the package `climetrics.` These represent monthly mean annual temperature from Jan 1991 to Dec 2020. The geographical area covers North of France, Great Britain and West of Norway.
```{r}

# path to the dataset folder
filePath <- system.file("external/", package="climetrics") 
tmean <- rast(paste0(filePath,'/tmean.tif'))
plot(tmean[[1]])

# corresponding dates
n <- readRDS(paste0(filePath,'/dates.rds')) 

# get averages per year
terra::time(tmean) <- as.Date(n)
tmean <- tapp(tmean, "years", mean)

# project to equal area
tmean <- terra::project(tmean,Eckt)

# Global continental lines
globe_lines <- vect(rnaturalearth::ne_countries(scale = "small"))
globe_lines <- terra::aggregate(globe_lines)

```
# Calculate velocities

## `Climetrics` 
This package is based on the package vocc (not VoCC!). I found that both packages have an issue when calculating the spatial gradient. The issue is that when extracting environmental data from the RasterStack they use only the first year to calculate the spatial gradient. Instead, the package VoCC uses the mean of all years (calc(r,mean)), which is the correct thing to do! To prove this issue, I calculate velocity with this package using the both the default (wrong) method and the corrected procedure (using mean raster).
```{r}

start <- Sys.time()

### Wrong way
# Velocity
v_climetrics1 <- climetrics:::gVelocity(tmean)

climetrics_time <- Sys.time() - start

# Spatial gradient (wrong way)
spgrad_climetrics1 <- climetrics:::.spatialgradTerra(tmean)

spgrad_climetrics1$NS[is.na(spgrad_climetrics1$NS)] <- 0
spgrad_climetrics1$WE[is.na(spgrad_climetrics1$WE)] <- 0
spgrad_climetrics1$NAsort <- ifelse((abs(spgrad_climetrics1$NS)+abs(spgrad_climetrics1$WE)) == 0, NA, 1)
spgrad_climetrics1$Grad <- spgrad_climetrics1$NAsort * sqrt((spgrad_climetrics1$WE^2) + (spgrad_climetrics1$NS^2))

# Angles
angle_climatrics1 <- spgrad_climetrics1$angle


### Right way
# Trend
trend_climatrics <- climetrics:::.tempgradTerra(tmean)
# Spatial gradient
spgrad_climetrics2 <- climetrics:::.spatialgradTerra(mean(tmean))

spgrad_climetrics2$NS[is.na(spgrad_climetrics2$NS)] <- 0
spgrad_climetrics2$WE[is.na(spgrad_climetrics2$WE)] <- 0
spgrad_climetrics2$NAsort <- ifelse((abs(spgrad_climetrics2$NS)+abs(spgrad_climetrics2$WE)) == 0, NA, 1)
spgrad_climetrics2$Grad <- spgrad_climetrics2$NAsort * sqrt((spgrad_climetrics2$WE^2) + (spgrad_climetrics2$NS^2))

# Angles
angle_climatrics2 <- spgrad_climetrics2$angle

# Velocity
v_climetrics2 <- climetrics:::.calcvelocity(grad = spgrad_climetrics2,
                                            slope = trend_climatrics,
                                            .terra = TRUE)

```

## `vocc`
Note that the same issue described above happens here. Thus, I calculate velocity with this package using the both the default (wrong) and the correct procedure (using mean raster).
```{r}

# Trend
start <- Sys.time()

trend_vocc = vocc::calcslope(rx = stack(tmean), 
                             divisor = 1) # to get C/year

### Wrong way
# Spatial gradient
spgrad_out_vocc1 = vocc::spatialgrad(rx = stack(tmean), 
                                     y_dist = res(tmean),
                                     y_diff = NA) 
# Angle
angle_vocc1 = spgrad_out_vocc1$angle

# Calculating temperature velocity 
v_vocc1 = vocc::calcvelocity(grad = spgrad_out_vocc1, 
                             slope = trend_vocc)
v_vocc_rast1 <- rast(tmean[[1]])
v_vocc_rast1[] <- v_vocc1$velocity

vocc_time <- Sys.time() - start

### Right way
# spatial gradient
spgrad_out_vocc2 = vocc::spatialgrad(rx = stack(mean(tmean)), 
                                     y_dist = res(tmean),
                                     y_diff = NA) 
# Angle
angle_vocc2 = spgrad_out_vocc2$angle

# Calculating temperature velocity 
v_vocc2 = vocc::calcvelocity(grad = spgrad_out_vocc2, 
                             slope = trend_vocc)
v_vocc_rast2 <- rast(tmean[[2]])
v_vocc_rast2[] <- v_vocc2$velocity

```

## `VoCC`
```{r}

start <- Sys.time()

# calculate the trend
trend_VoCC = VoCC1::tempTrend(r = stack(tmean),
                              th = 0.25*nlyr(tmean) ## set minimum # obs. to 1/4 time series length
)

# calculate the spatial gradient
spgrad_VoCC = VoCC1::spatGrad(r = stack(tmean), 
                              projected = TRUE) 

# Calculating temperature velocity 
v_VoCC = VoCC1::gVoCC(tempTrend = trend_VoCC, 
                      spatGrad = spgrad_VoCC)

# Angle
angle_VoCC = values(spgrad_VoCC[[2]])

VoCC_time <- Sys.time() - start

```

## `Bioshifts`
Functions adapted from climetrics (because it is based on the package `terra`, which allows faster computation relative to other packages that are based on `raster`), appling modifications to generate results in km/year.
```{r}

start <- Sys.time()

# Trend
trend_bio <- temp_grad(tmean, th = 0.25*nlyr(tmean))

# Spatial gradient
spgrad_bio <- spatial_grad(tmean)

# Velocity
v_bio <- gVelocity(spgrad_bio,trend_bio,truncate = TRUE)

# Angle
angle_bio = spgrad_bio$angle

bio_time <- Sys.time() - start

```

## Gael's function
```{r}

# spatial gradient
spgrad_gael <- Gael_grad(stack(tmean))
# trend (use VoCC trend function)
trend_gael <- VoCC1::tempTrend(r = stack(tmean), th = 10) 
trend_gael = resample(trend_gael, spgrad_gael)

v_gael = trend_gael[[1]] / spgrad_gael 
v_gael = resample(v_gael, stack(tmean))

```

# Extra I - Tests whether we can use velocity North provided directly from the function output
Tests whether we can use velocity North provided directly from the function output, or if it's necessary to calculate the resultant velocity at the angle of the gradient.
According to the calculations below, we can use the gradient North directly. It is not necessary to convert velocity rates to the North direction using angles.
```{r}

# get data
v_data <- as.data.frame(spgrad_bio)
v_data <- na.omit(v_data)

# Convert gradients to the North direction using the angle
temperature_change_rate <- v_data$Grad  # Â°C/km
vel_angle <- v_data$angle

# Calculate temperature change in North and West directions
temperature_change_north <- temperature_change_rate * cos(.rad(vel_angle))
temperature_change_west <- temperature_change_rate * sin(.rad(vel_angle))

plot(v_data$NS,temperature_change_north,
     xlab="Change given",ylab = "Change calculated from angle")
plot(v_data$WE,temperature_change_west,
     xlab="Change given",ylab = "Change calculated from angle")

all.equal(v_data$NS,temperature_change_north)
all.equal(v_data$WE,temperature_change_west)

```
See! Use NS/WE directly.

# Extra II - We expect velocity North to be greater when angle is North
We expect velocity North to be greater when angle is North, and same direct comparison for South direction.
```{r}

plot(v_data$angle,v_data$NS,
     xlab="Gradient direction",ylab = "Temperature change North -> South")

plot(v_data$angle,v_data$WE,
     xlab="Gradient direction",ylab = "Temperature change West -> East")

plot(angle_degrees_NS,v_data$NS,
     xlab="Gradient direction",ylab = "Temperature change North -> South")

plot(angle_degrees_WE,v_data$WE,
     xlab="Gradient direction",ylab = "Temperature change West -> East")

```

Indeed!

# Extra III - Trajectory lines
```{r}

## get the set of starting cells for the trajectories
tmean2 <- terra::project(tmean,"+proj=lonlat")
tmean2 <- mean(tmean2)
tmean2 <- mask(tmean2, globe_lines)
tmean2 <-  raster::raster(tmean2)

angle_rast <- v_bio$GradVel
angle_rast[v_data$icell] <- v_data$angle
angle_rast <- terra::project(angle_rast,tmean2)
angle_rast <- mask(angle_rast, globe_lines)
angle_rast <- raster::raster(angle_rast)

vel_rast <- v_bio$GradVel
vel_rast <- terra::project(vel_rast,tmean2)
vel_rast <- mask(vel_rast, globe_lines)
vel_rast <- raster::raster(vel_rast)

NAcells <- raster::brick(tmean2,angle_rast,vel_rast)
NAcells <- all(!is.na(NAcells))
NAcells[NAcells==0] <- NA

tmean2 <- tmean2*NAcells
angle_rast <- angle_rast*NAcells
vel_rast <- vel_rast*NAcells

lonlat <- na.omit(as.data.frame(tmean2, xy=TRUE))[,1:2]

## calculate trajectory:
traj = voccTraj(correct = TRUE,
                lonlat = lonlat, # starting lat lon coords
                vel = vel_rast, # velocity 
                ang = angle_rast, # angle
                mn = tmean2, # mean temp 
                tyr = 30 # length of period of interest, years
)

## create a spatial line data frame from traj
lns <- trajLine(x = traj)
lns <- terra::vect(lns)

myramp <- colorRampPalette(colors = c("red","green","blue","yellow","red"))(360)

{
  layout(matrix(c(1,1,1,2), nrow = 1, ncol = 4, byrow=T))
  plot(rast(angle_rast), 
       col = myramp)
  # plot(lns,add=TRUE)
  plot(globe_lines,add=TRUE)
  plotrix::polar.plot(
    start = 90,
    lengths = c(rnorm(360,mean = 1, sd = 0.001)),
    polar.pos = seq(0,360,by=1),
    cex=.01,
    clockwise = TRUE,
    show.grid.labels=0,
    line.col=myramp)
}

{
  layout(matrix(c(1,1,1,2), nrow = 1, ncol = 4, byrow=T))
  plot(rast(angle_rast), 
       col = myramp)
  plot(lns,add=TRUE)
  plot(globe_lines,add=TRUE)
  plotrix::polar.plot(
    start = 90,
    lengths = c(rnorm(360,mean = 1, sd = 0.001)),
    polar.pos = seq(0,360,by=1),
    cex=.01,
    clockwise = TRUE,
    show.grid.labels=0,
    line.col=myramp)
}
```


# Compare results
## Velocities maps
```{r}
tmp <- rast(c(climetrics1=v_climetrics1,
              climetrics2=v_climetrics2,
              vocc1=v_vocc_rast1,
              vocc2=v_vocc_rast2,
              VoCC=rast(v_VoCC[[1]]),
              v_bio=v_bio))
# very different values
tmp
plot(tmp)
```

## Velocities correlations
```{r message=FALSE, warning=FALSE}

velocities <- data.frame(tmp)

ggpairs(velocities)

```

Velocity values for `climatrics1` and `vocc1` are identical (but not perfect because `climatrics1` squeezes outliers), but both are different from VoCC because they handle the spatial gradient differently. When we correct the velocities from climatrics and vocc (`climatrics2` and `vocc2`, respectively), the values are identical to the ones in `VoCC.`
Values from `bioshifts` is identical to `VoCC` (both in km/year)!

## Time for calculating velocities
```{r}
timesFuncs <- data.frame(t(data.frame(climetrics_time[[1]],vocc_time[[1]],VoCC_time[[1]],bio_time[[1]])))
names(timesFuncs) <- "elapsed"
timesFuncs$Package <- gsub("_time..1..","",rownames(timesFuncs))

ggplot(timesFuncs, aes(x = Package, y = elapsed))+
  geom_col() + ylab("Time elapsed (seconds)")

```


# North direction velocities
Here, we can add Gael's results for North velocity
```{r message=FALSE, warning=FALSE}

# Convert all velocities to the North direction
velocities_North <- data.frame(
  climetrics1=values(v_climetrics1)[,1] * cos(.rad(angle_climatrics1)),
  climetrics2=values(v_climetrics2)[,1] * cos(.rad(angle_climatrics2)),
  vocc1=values(v_vocc_rast1)[,1] * cos(.rad(angle_vocc1)),
  vocc2=values(v_vocc_rast2)[,1] * cos(.rad(angle_vocc2)),
  VoCC=raster::values(v_VoCC[[1]]) * cos(.rad(angle_VoCC)),
  v_bio=values(v_bio)[,1] * cos(.rad(angle_bio)),
  v_gael=values(rast(v_gael))[,1])

ggpairs(velocities_North)

```
VoCC and bioshifts still identical.
Gael's code generates very different results.

## Compare velocities with projected and unprojected raster files
```{r}

# Use the same set of climate variables
tmean <- rast(paste0(filePath,'/tmean.tif'))
# project to equal-area
tmean_proj <- terra::project(tmean,Eckt)

# Use rts function in the rts package to make a raster time series:
tmean.t <- rts(tmean,n)
tmean.t_proj <- rts(tmean_proj,n)


####
# VoCC unprojected
# Trend
trend_VoCC = VoCC1::tempTrend(r = stack(tmean),
                              th = 0.25*nlyr(tmean))

# Spatial gradient
spgrad_VoCC = VoCC1::spatGrad(r = stack(tmean), 
                              projected = FALSE) 

# Velocity 
v_VoCC = VoCC1::gVoCC(tempTrend = trend_VoCC, 
                      spatGrad = spgrad_VoCC)

####
# VoCC projected
# Trend
trend_VoCC = VoCC1::tempTrend(r = stack(tmean_proj),
                              th = 0.25*nlyr(tmean_proj) ## set minimum # obs. to 1/4 time series length
)
# Spatial gradient
spgrad_VoCC = VoCC1::spatGrad(r = stack(tmean_proj), 
                              projected = TRUE) 
# Velocity 
v_VoCC2 = VoCC1::gVoCC(tempTrend = trend_VoCC, 
                       spatGrad = spgrad_VoCC)

## Compare velocities 
v_VoCC[[1]]
v_VoCC2[[1]]

####
# bioshifts unprojected
# Trend
trend_bio <- temp_grad(tmean, th = 0.25*nlyr(tmean))
# Spatial gradient
spgrad_bio <- spatial_grad(tmean)
# Velocity
v_bio <- gVelocity(spgrad_bio,trend_bio)

####
# bioshifts projected
# Trend
trend_bio <- temp_grad(tmean_proj, th = 0.25*nlyr(tmean_proj))
# Spatial gradient
spgrad_bio <- spatial_grad(tmean_proj)
# Velocity
v_bio2 <- gVelocity(spgrad_bio,trend_bio)

## Compare velocities 
v_bio
v_bio2

```

## Why VoCC results are different when using projected and unprojected data?
Inspection of VoCC package functions indicates that when using unprojected data, the results are given in the unit of the environmental data provided. As the unit of projected data is usually in meters, the results of the projected data are 1000 smaller then the projected (1km = 1000 meters).
To make results identical between projected and unprojected data (both in C/km), transform units:
```{r}
summary(v_VoCC[[1]])
summary(v_VoCC2[[1]]/1000)
```

